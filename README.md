JavaExam
1. Рыжов Никита Андреевич
2. Абстрактный класс - класс, который содержит хотя бы один абстрактный метод (метод без тела). 
Интерфейс - полностью абстрактный класс (все методы не имеют тела). 
Главное отличие класса от интерфейса в том, что он состоит из интерфейса и его реализации. Любой класс неявно определяет свой интерфейс. Класс может наследовать только один класс(extends), в то время как реализовать может хоть сколько интерфейсов (implement). При наследовании от класса необходимо переопределить все его абстрактные методы. При реализации интерфейса нужно переопределить все его методы.
3. Сборку мусора (или Garbage Collection) можно насильно вызвать при помощи System.gc(). Однако JVM не гарантирует что сборщик мусора будет вызван. Если и вызывать gc, то только если вы уверены, что скопились неиспользуемые объекты.
4. Явное приведение типов требуется когда нужно обращаться к методам объекта, объявленного через ссылку на родительский(супер) класс. 
5. Конструктор используется при создании объекта класса и имеет такое же имя, что и класс. Он может быть вызван при помощи оператора new. В отличии от метода конструктор не возвращает значение.
6. Конструкторы можно вызывать один из другого. Чтобы в классе было несколько разных конструкторов необходимо, чтобы они принимали разные параметры.
7. JRE - Java Runtime Environment. Среда выполнения Java предназначенная только для запуска готовых приложений Java. Содержит только реализацию виртуальной машины и набор стандартных библиотек.
JDK - Java Delevopment Kit. Средство для разработчиков, которое включает в себя стандартные библиотеки с их исходным кодом, набор утилит, таких как: - java - реализация JVM; - javac - компилятор Java; - jar - архиватор формата JAR и тд.
8. Исключения FileNotFoundExeption нужно перехватывать раньше IOException, т.к. FileNotFoundExeption наследуется от IOException. Все исключения нужно обрабатывать в порядке их иерархии наследования от потомков к предкам.
9. Внутренние классы, описанные в методе, имеют доступ к локальным переменным этого метода, если они объявлены с модификатором final.
10. Подкласс может обратится к конструктору супер класса при помощи super(). А к методу супер класса при помощи конструкции super.metod().
11. Стек организовывается по принципу LIFO(последний вошёл, первый вышел). Очередь по принципу FIFO(первый вошёл, первый вышел).
12. Young generation - часть памяти в JVM. 
При использовании сборщика мусора вся память делится на области, называемые поколениями. Только что созданные объекты помещаются в Young generation. Объекты пережившие несколько сборок мусора попадают в Old generation.
Young generation меньше по размерам чем Old generetion, поэтому сборка мусора там производится чаще; большинство объектов тут мусор.
Также есть область памяти называемая Permanent generation, в ней JVM хранит различную информацию и она также может быть очищена сборщиком мусора.
13. Паттерн Наблюдатель(Listener).
Этот паттерн определяет зависимость "один ко многим" между объектами так, что когда один объект меняет своё состояние(происходит некое событие), то все зависимые объекты оповещаются и обновляются автоматически.
14. По умолчанию модификатор доступа становиться равным packege, т.е. на уровне пакета, поэтому чтобы к классу имели доступ только классы из того-же пакета необязательно указывать модификатор.
Модификатор public позволяет видеть поля всем.
Private - только в текущем классе. Класс может видеть вложенный в него класс с модификатором private.
Protected - поля доступны текущему классу и его наследникам.
15. Статические вложенные классы не имеют доступа к не-статическим полям и методам внешнего класса, в то время как не-статические имеют к ним доступ. Объект не-статических внутренних классов можно создать через объект внешнего класса.
16. К не-статической переменной нельзя обратится из статического метода, т.к. статические методы не привязываются к объекту данного класса. При необходимости можно обратится к переменной через ссылку на уже созданный объект данного класса.
17. Примитивные типы и ссылочные типы.
Примитивные типы: byte, int, double, boolean, char, ...
Ссылочные типы: объекты.
18. Переопределение метода (Override) используется при наследовании или реализации интерфейса, когда мы определяем метод супер класса или интерфейса. 
Перегрузка метода (Overload) означает создание метода с таким же названием, что и уже существующий, но с другим набором параметров.
19. Итератор - паттерн, предназначенный для прохода по элементам списка. Позволяет перебирать, добавлять и удалять элементы из списка.
20. Типы исключений: checked и unchecked.
Checked исключения, это те, которые нужно обрабатывать блоком catch или описываться в сигнатуре метода после ключевого слова throws. 
Unchecked могут не обрабатываться и не быть описанными.
Unchecked исключения  - наследованные от RuntimeException, а checked - от Exception(не включая unchecked).
21. Оператор throw используется для возбуждения исключения вручную. (throw new IOExeption())
Оператор throws используется у метода, и означает что описанные после него исключения будут отлавливаться в теле этого метода.
22. Блок finally является частью конструкции try-catch-finally и вызывается всегда независимо от того как завершился блок try.
23. Finalize - блок, который можно объявить в классе. Он будет выполнен(НО не гарантированно) при удалении объекта этого класса сборщиком мусора.
24. Вложенные классы разделяются на статические и не-статические. (вопр.15)
Не-статические обычно называются внутренними классами. 
Не-статические в свою очередь делятся на внутренние классы-члены, локальные классы и анонимные классы.
Внутренние классы-члены ассоциируются с экземпляром класса. Они имеют доступ ко всем его полям и методам.
Локальные классы обычно определяются в методах некоторого другого класса. Как и предыдущие они имеют доступ к полям экземпляра внешнего класса. Кроме того они могут обращаться к локальным переменным метода, если они объявлены с модификатором final.
Анонимные классы - локальные классы без имени. У них невозможно описать конструктор, т.к. класс не имеет имени. Аргументы указанные в скобках используются для вызова конструктора базового класса и теми же параметрами. (new Thread(new Runnable(){ . . . public void run(){} . . .}).start();)
